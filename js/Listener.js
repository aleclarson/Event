// Generated by CoffeeScript 1.12.4
var Listener, Tracer, Type, emptyFunction, getProto, impls, type;

emptyFunction = require("emptyFunction");

getProto = require("getProto");

Tracer = require("tracer");

Type = require("Type");

type = Type("Listener");

type.trace();

type.defineArgs(function() {
  return {
    create: function(args) {
      if (typeof args[0] === "function") {
        args[1] = args[0];
        args[0] = void 0;
      }
      return args;
    },
    defaults: [2e308],
    types: [Number, Function]
  };
});

type.defineValues(function(maxCalls, callback) {
  return {
    maxCalls: maxCalls,
    calls: maxCalls !== 2e308 ? 0 : void 0,
    _event: null,
    _impl: impls.detached,
    _notify: emptyFunction,
    _callback: callback,
    _onDetach: emptyFunction
  };
});

type.defineGetters({
  isListening: function() {
    return this._notify !== emptyFunction;
  },
  notify: function() {
    return this._notify;
  }
});

type.defineMethods({
  attach: function(event) {
    return this._impl.attach.call(this, event);
  },
  detach: function() {
    return this._impl.detach.call(this);
  },
  start: function() {
    return this._impl.start.call(this);
  },
  stop: function() {
    return this._impl.stop.call(this);
  },
  onDetach: function(callback) {
    var callbackBefore;
    if (this._onDetach === emptyFunction) {
      this._onDetach = callback;
      return;
    }
    callbackBefore = this._onDetach;
    this._onDetach = function() {
      callbackBefore();
      return callback();
    };
  },
  _attach: function(event) {
    this._impl = impls.stopped;
    this._event = event;
    this._event._onAttach(this);
    return this;
  },
  _detach: function() {
    this._impl = impls.detached;
    this._notify = emptyFunction;
    this._event._onDetach(this);
    this._event = null;
    this._onDetach();
  },
  _start: function() {
    this._impl = impls.started;
    this._notify = this.maxCalls === 2e308 ? this._notifyUnlimited : this._notifyLimited;
    return this;
  },
  _stop: function() {
    this._impl = impls.stopped;
    this._notify = emptyFunction;
  },
  _notifyUnlimited: function(args) {
    this._callback.apply(null, args);
  },
  _notifyLimited: function(args) {
    this.calls += 1;
    this._callback.apply(null, args);
    if (this.calls === this.maxCalls) {
      this.detach();
    }
  }
});

module.exports = Listener = type.build();

impls = {
  detached: {
    attach: Listener.prototype._attach,
    detach: emptyFunction,
    start: emptyFunction.thatReturnsThis,
    stop: emptyFunction
  },
  stopped: {
    attach: emptyFunction.thatReturnsThis,
    detach: Listener.prototype._detach,
    start: Listener.prototype._start,
    stop: emptyFunction
  },
  started: {
    attach: emptyFunction.thatReturnsThis,
    detach: Listener.prototype._detach,
    start: emptyFunction.thatReturnsThis,
    stop: Listener.prototype._stop
  }
};
