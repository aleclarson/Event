// Generated by CoffeeScript 1.11.1
var Listener, Type, assertType, emptyFunction, immediate, type;

emptyFunction = require("emptyFunction");

assertType = require("assertType");

immediate = require("immediate");

Type = require("Type");

Listener = require("./Listener");

type = Type("ListenerArray");

type.defineOptions({
  async: Boolean.withDefault(false)
});

type.defineValues(function(options) {
  return {
    _value: null,
    _length: 0,
    _isNotifying: false,
    _detachQueue: [],
    _notifyQueue: options.async ? [] : void 0
  };
});

type.defineGetters({
  length: function() {
    return this._length;
  },
  isNotifying: function() {
    return this._isNotifying;
  }
});

type.defineMethods({
  attach: function(listener) {
    var oldValue;
    assertType(listener, Listener);
    if (!(oldValue = this._value)) {
      this._update(listener, 1);
      return;
    }
    if (oldValue.constructor === Listener) {
      this._update([oldValue, listener], 2);
      return;
    }
    this._update(oldValue, oldValue.push(listener));
  },
  notify: function(args) {
    if (!this._value) {
      return;
    }
    if (!this._notifyQueue) {
      this._isNotifying = true;
      this._notify(args);
      this._isNotifying = false;
      this._flush();
      return;
    }
    if (this._isNotifying || this._notifyQueue.length) {
      this._notifyQueue.push(args);
      return;
    }
    this._notifyAsync(args);
  },
  detach: function(listener) {
    var index, newCount, oldValue;
    assertType(listener, Listener);
    if (this._isNotifying) {
      this._detachQueue.push(listener);
      return;
    }
    if (!(oldValue = this._value)) {
      throw Error("No listeners are attached!");
    }
    if (oldValue.constructor === Listener) {
      if (listener !== oldValue) {
        throw Error("Listener is not attached to this ListenerArray!");
      }
      this._update(null, 0);
      return;
    }
    index = oldValue.indexOf(listener);
    if (index < 0) {
      throw Error("Listener is not attached to this ListenerArray!");
    }
    oldValue.splice(index, 1);
    newCount = oldValue.length;
    if (newCount === 1) {
      this._update(oldValue[0], 1);
    } else {
      this._update(oldValue, newCount);
    }
  },
  reset: function() {
    if (this._length) {
      this._update(null, 0);
    }
  },
  _update: function(newValue, newLength) {
    this._value = newValue;
    this._length = newLength;
  },
  _notify: function(args) {
    if (this._length === 1) {
      return this._value.notify(args);
    } else {
      return this._value.forEach(function(listener) {
        return listener.notify(args);
      });
    }
  },
  _notifyAsync: function(args) {
    this._isNotifying = true;
    immediate(this, function() {
      var next;
      this._value && this._notify(args);
      this._isNotifying = false;
      this._flush();
      if (next = this._notifyQueue.shift()) {
        this._notifyAsync(next[0], next[1]);
      }
    });
  },
  _flush: function() {
    var index, length, listeners;
    length = (listeners = this._detachQueue).length;
    if (length === 0) {
      return;
    }
    if (length === 1) {
      this.detach(listeners.pop());
      return;
    }
    index = -1;
    while (++index < length) {
      this.detach(listeners[index]);
    }
    listeners.length = 0;
  }
});

module.exports = type.build();
